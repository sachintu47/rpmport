diff --git a/lib/fsm.cc b/lib/fsm.cc
index 63580c2..e8a2c01 100644
--- a/lib/fsm.cc
+++ b/lib/fsm.cc
@@ -4,6 +4,10 @@
  */
 
 #include "system.h"
+#if defined(__MVS__)
+#include <sys/time.h>
+#include <sys/sys_time.h>
+#endif
 
 #include <inttypes.h>
 #include <utime.h>
@@ -58,6 +62,11 @@ struct filedata_s {
     const char *suffix;
     char *fpath;
     struct stat sb;
+#ifdef __MVS__
+   uint16_t ccsid;
+   uint8_t  txtflag;
+   uint32_t genvalue;
+#endif
 };
 
 /* 
@@ -167,7 +176,7 @@ static int fsmOpen(int *wfdp, int dirfd, const char *dest)
 {
     int rc = 0;
     /* Create the file with 0200 permissions (write by owner). */
-    int fd = openat(dirfd, dest, O_WRONLY|O_EXCL|O_CREAT, 0200);
+    int fd = openat(dirfd, dest, O_WRONLY|O_EXCL|O_CREAT,  (0200));
 
     if (fd < 0)
 	rc = RPMERR_OPEN_FAILED;
@@ -293,7 +302,7 @@ static int fsmMkdir(int dirfd, const char *path, mode_t mode)
     int rc = mkdirat(dirfd, path, (mode & 07777));
     if (_fsm_debug)
 	rpmlog(RPMLOG_DEBUG, " %8s (%d %s, 0%04o) %s\n", __func__,
-	       dirfd, path, (unsigned)(mode & 07777),
+	       dirfd, path, ((unsigned)(mode & 07777)),
 	       (rc < 0 ? strerror(errno) : ""));
     if (rc < 0)	rc = RPMERR_MKDIR_FAILED;
     return rc;
@@ -302,8 +311,19 @@ static int fsmMkdir(int dirfd, const char *path, mode_t mode)
 static int fsmOpenat(int *wfdp, int dirfd, const char *path, int flags, int dir)
 {
     struct stat lsb, sb;
-    int sflags = flags | O_NOFOLLOW;
-    int fd = openat(dirfd, path, sflags);
+    int fd, sflags = flags | O_NOFOLLOW;
+#ifdef __MVS__
+    if (path && path[0] == '/' && path[1] == '\0') {
+       fd = openat(dirfd, path, flags);    // O_RDONLY only, no O_NOFOLLOW
+    }
+    else
+    {
+       fd = openat(dirfd, path, sflags);
+    }
+#else
+    fd = openat(dirfd, path, sflags);
+#endif
+    
     int rc = 0;
 
     /*
@@ -360,11 +380,11 @@ static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,
 	rc = fsmMkdir(dirfd, dn, mode);
 
     if (!rc) {
-	rc = fsmOpenat(fdp, dirfd, dn, O_RDONLY|O_NOFOLLOW, 1);
+	rc = fsmOpenat(fdp, dirfd, dn, O_RDONLY, 1);
     }
 
     if (!rc) {
-	rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, *fdp, apath, apath, mode, op);
+	rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, *fdp, apath, apath,mode, op);
     }
 
     /* Run fsm file post hook for all plugins */
@@ -373,7 +393,7 @@ static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,
     if (!rc) {
 	rpmlog(RPMLOG_DEBUG,
 		"%s directory created with perms %04o\n",
-		apath, (unsigned)(mode & 07777));
+		apath,((unsigned)(mode & 07777)));
     }
 
     return rc;
@@ -442,7 +462,7 @@ static int fsmMkfifo(int dirfd, const char *path, mode_t mode)
 
     if (_fsm_debug) {
 	rpmlog(RPMLOG_DEBUG, " %8s (%d %s, 0%04o) %s\n",
-	       __func__, dirfd, path, (unsigned)(mode & 07777),
+	       __func__, dirfd, path, ((unsigned)(mode & 07777)),
 	       (rc < 0 ? strerror(errno) : ""));
     }
 
@@ -459,7 +479,7 @@ static int fsmMknod(int dirfd, const char *path, mode_t mode, dev_t dev)
 
     if (_fsm_debug) {
 	rpmlog(RPMLOG_DEBUG, " %8s (%d %s, 0%o, 0x%x) %s\n",
-	       __func__, dirfd, path, (unsigned)(mode & ~07777),
+	       __func__, dirfd, path, ((unsigned)(mode & ~07777)),
 	       (unsigned)dev, (rc < 0 ? strerror(errno) : ""));
     }
 
@@ -478,10 +498,10 @@ static void removeSBITS(int dirfd, const char *path)
 	int rc = 0;
 	/* We now know it's not a link so no need to worry about following */
 	if ((stb.st_mode & 06000) != 0) {
-	    rc += fchmodat(dirfd, path, stb.st_mode & 0777, 0);
+	    rc += fchmodat(dirfd, path, (stb.st_mode & 0777), 0);
 	}
 #ifdef WITH_CAP
-	if (stb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)) {
+	if ((stb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH))) {
 	    rc += cap_set_fileat(dirfd, path, NULL);
 	}
 #endif
@@ -492,7 +512,7 @@ static void fsmDebug(const char *dn, const char *fpath, rpmFileAction action,
 		     const struct stat *st)
 {
     rpmlog(RPMLOG_DEBUG, "%-10s %06o%3d (%4d,%4d)%6d %s%s\n",
-	   fileActionString(action), (int)st->st_mode,
+	   fileActionString(action),(int)(st->st_mode),
 	   (int)st->st_nlink, (int)st->st_uid,
 	   (int)st->st_gid, (int)st->st_size,
 	    (dn ? dn : ""), (fpath ? fpath : ""));
@@ -593,7 +613,7 @@ static int fsmChmod(int fd, int dirfd, const char *path, mode_t mode)
 	rc = fchmod(fd, fmode);
 	if (rc < 0) {
 	    struct stat st;
-	    if (fstat(fd, &st) == 0 && (st.st_mode & 07777) == fmode) {
+	    if (fstat(fd, &st) == 0 && (st.st_mode & 07777) == (fmode)) {
 		rc = 0;
 	    }
 	}
@@ -602,7 +622,7 @@ static int fsmChmod(int fd, int dirfd, const char *path, mode_t mode)
 	if (rc < 0) {
 	    struct stat st;
 	    if (fstatat(dirfd, path, &st, AT_SYMLINK_NOFOLLOW) == 0 &&
-		    (st.st_mode & 07777) == fmode) {
+		    (st.st_mode & 07777) == (fmode)) {
 		rc = 0;
 	    }
 	}
@@ -615,6 +635,7 @@ static int fsmChmod(int fd, int dirfd, const char *path, mode_t mode)
     return rc;
 }
 
+#if 0
 static int fsmUtime(int fd, int dirfd, const char *path, mode_t mode, time_t mtime)
 {
     int rc = 0;
@@ -637,6 +658,37 @@ static int fsmUtime(int fd, int dirfd, const char *path, mode_t mode, time_t mti
 	rc = 0;
     return rc;
 }
+#endif 
+
+static int fsmUtime(int fd, int dirfd, const char *path, mode_t mode, time_t mtime)
+{
+    int rc = 0;
+
+    if (fd >= 0) {
+        // futimes() expects struct timeval
+        struct timeval stamps[2] = {
+            { .tv_sec = mtime, .tv_usec = 0 },
+            { .tv_sec = mtime, .tv_usec = 0 },
+        };
+        rc = futimes(fd, stamps);
+    } else {
+        // utimensat() expects struct timespec
+        struct timespec stamps[2] = {
+            { .tv_sec = mtime, .tv_nsec = 0 },
+            { .tv_sec = mtime, .tv_nsec = 0 },
+        };
+        rc = utimensat(dirfd, path, stamps, AT_SYMLINK_NOFOLLOW);
+    }
+
+    if (_fsm_debug)
+        rpmlog(RPMLOG_DEBUG, " %8s (%d - %d %s, 0x%x) %s\n", __func__,
+               fd, dirfd, path, (unsigned)mtime, (rc < 0 ? strerror(errno) : ""));
+    if (rc < 0) rc = RPMERR_UTIME_FAILED;
+    /* ...but utime error is not critical for directories */
+    if (rc && S_ISDIR(mode))
+        rc = 0;
+    return rc;
+}
 
 static int fsmVerify(int dirfd, const char *path, rpmfi fi)
 {
@@ -748,19 +800,19 @@ static int fsmSetmeta(int fd, int dirfd, const char *path,
 	rc = fsmChown(fd, dirfd, path, st->st_mode, st->st_uid, st->st_gid);
     }
     if (!rc && !S_ISLNK(st->st_mode)) {
-	rc = fsmChmod(fd, dirfd, path, st->st_mode);
+	rc = fsmChmod(fd, dirfd, path, (st->st_mode));
     }
     /* Set file capabilities (if enabled) */
     if (!rc && !nofcaps && S_ISREG(st->st_mode) && !getuid()) {
 	rc = fsmSetFCaps(fd, dirfd, path, rpmfiFCaps(fi));
     }
     if (!rc) {
-	rc = fsmUtime(fd, dirfd, path, st->st_mode, rpmfiFMtime(fi));
+	rc = fsmUtime(fd, dirfd, path, (st->st_mode), rpmfiFMtime(fi));
     }
     if (!rc) {
 	rc = rpmpluginsCallFsmFilePrepare(plugins, fi,
 					  fd, path, dest,
-					  st->st_mode, action);
+					  (st->st_mode), action);
     }
     free(dest);
 
@@ -770,7 +822,6 @@ static int fsmSetmeta(int fd, int dirfd, const char *path,
 static int fsmCommit(int dirfd, char **path, rpmfi fi, rpmFileAction action, const char *suffix)
 {
     int rc = 0;
-
     /* XXX Special case /dev/log, which shouldn't be packaged anyways */
     if (!(S_ISSOCK(rpmfiFMode(fi)) && IS_DEV_LOG(*path))) {
 	const char *nsuffix = (action == FA_ALTNAME) ? SUFFIX_RPMNEW : NULL;
@@ -911,7 +962,17 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 
 	/* Remap file perms, owner, and group. */
 	rc = rpmfiStat(fi, (fp->skip == 0), &fp->sb);
-
+	#ifdef __MVS__
+	    /* Copy z/OS-specific header values into our per-file state so we can
+	     *        apply them at install time. Replace the accessor names below with
+	     *               the real ones you use to get arrays from rpmfi. */
+	if (!rc) {
+	    /* Example accessor names: replace with your actual api */
+	     fp->ccsid = (uint16_t) (rpmfiFccsid(fi) ? rpmfiFccsid(fi) : 0);
+	     fp->txtflag = (uint8_t) (rpmfiFtxtflag(fi) ? rpmfiFtxtflag(fi) : 0);
+	     fp->genvalue = (uint32_t) (rpmfiFgenvalue(fi) ? rpmfiFgenvalue(fi) : 0);
+	}
+#endif
 	/* Hardlinks are tricky and handled elsewhere for install */
 	fp->setmeta = (fp->skip == 0) &&
 		      (fp->sb.st_nlink == 1 || fp->action == FA_TOUCH);
@@ -961,7 +1022,7 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	    /* Run fsm file pre hook for all plugins */
 	    if (!rc)
 		rc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,
-					      fp->sb.st_mode, fp->action);
+					      (fp->sb.st_mode), fp->action);
 	    if (rc)
 		goto setmeta; /* for error notification */
 
@@ -1020,8 +1081,9 @@ int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
                 }
             } else {
                 /* XXX Special case /dev/log, which shouldn't be packaged anyways */
-                if (!IS_DEV_LOG(fp->fpath))
+                if (!IS_DEV_LOG(fp->fpath)) {
                     rc = RPMERR_UNKNOWN_FILETYPE;
+		}
             }
 
 setmeta:
@@ -1073,6 +1135,29 @@ setmeta:
 
 	    if (!rc)
 		rc = fsmCommit(di.dirfd, &fp->fpath, fi, fp->action, fp->suffix);
+#ifdef __MVS__
+	    if (!rc && fp->setmeta) {
+	        /* Apply CCSID/TXTFLAG/GENVALUE on final committed path */
+		char fullpath[PATH_MAX];
+		snprintf(fullpath, sizeof(fullpath), "%s/%s", rpmfiDN(fi), fp->fpath);
+
+			/* apply CCSID/TXTFLAG */
+	       		attrib_t attr;
+			memset(&attr, 0, sizeof(attr));
+			attr.att_filetagchg = 1;
+			attr.att_filetag.ft_ccsid   = fp->ccsid;
+			attr.att_filetag.ft_txtflag = fp->txtflag;
+			int rc2 = __chattr(fullpath, &attr, sizeof(attr));
+			/* apply GENVALUE bits */
+			attrib_t pbits;
+			memset(&pbits, 0, sizeof(pbits));
+			if (fp->genvalue & __ST_APF_AUTH){    pbits.att_apfauthmask = 1; pbits.att_apfauth= 1;	pbits.att_setgen=1; }
+			if (fp->genvalue & __ST_PROG_CTL){    pbits.att_progctlmask = 1; pbits.att_progctl = 1; pbits.att_setgen=1; }
+			if (fp->genvalue & __ST_NO_SHAREAS){  pbits.att_noshareasmask = 1; pbits.att_noshareas = 1; pbits.att_setgen=1;}
+			if (fp->genvalue & __ST_SHARE_LIB){   pbits.att_sharelibmask = 1; pbits.att_sharelib = 1; pbits.att_setgen=1;	}
+			int rc3 = __chattr(fullpath, &pbits, sizeof(pbits));
+	    }
+#endif
 
 	    if (!rc)
 		fp->stage = FILE_COMMIT;
@@ -1155,7 +1240,7 @@ int rpmPackageFilesRemove(rpmts ts, rpmte te, rpmfiles files,
         if (fp->action == FA_ERASE) {
 	    int missingok = (rpmfiFFlags(fi) & (RPMFILE_MISSINGOK | RPMFILE_GHOST));
 
-	    rc = fsmRemove(di.dirfd, fp->fpath, fp->sb.st_mode);
+	    rc = fsmRemove(di.dirfd, fp->fpath, (fp->sb.st_mode));
 
 	    /*
 	     * Missing %ghost or %missingok entries are not errors.
